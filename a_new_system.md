# A New System

### With the systems In the previous chapter I mentioned we wouldn't have to reinvent the wheel.

But what form does such a system take? How might these tools actually work applied to a realm other than that for which they were developed? It is doubtful that the translation will be one to one.

That hasn't kept Just dropping all of the U.S. Code into a repo has been done. It's not just a matter of using the tools As Shirky points out in his TED talk there are a number of instances of Github users hosting repos containing the full legal code of the state of Utah, for example. There are even state government initiatives with names like "Open Law," yet we've seen very little momentum in a shift to laws maintained or written in a way that matches the world of open source programming introduced in the previous section.

What's missing? What's the difference?

It has been eluded to in previous sections in passing, but now it is important to understand the idea of layers, and of dynamics. These terms are pulled from my experience in the world of user experience, and program design. They are terms used to discuss how users interact with a tool on a level above the execution of the tool's function. The function of a tool is, in a sense, blunt. A program is designed to do a thing, click the button, it does that thing. Layers are a way of conceptualizing the stacking of different functions, while dynamics are a way of thinking about the interplay that this stacking breeds. As an example: Git has a particular function. It tracks changes, associates those changes with identifying markers, and stores that information in such a way as to create the canonical repository described in the previous chapter. That is the function of Git. In the layer sense it is taking the normal behavior of coding, and adding a tracking layer. The addition of the tracking layer, then creates a different behavior or communication dynamic. In this case the dynamic is the ability to roll back changes, and to collaborate with a massive number of programmers at once. Taking this example a step further, Github has a function: to host and facilitate the sharing of Git repositories. This is a new layer on top of Git, and as Github performs its function it creates a new dynamic: sharing, and democratization of access of open repositories.

The value in understanding the concept of the "layer" and the "dynamic" comes from the need for a higher level discussion about tools for version control, tools for sharing, and tools for research like Stack Overflow. If you go to Stackoverflow.com today you'll notice that somewhere on the page it will likely say something to the effect of "a member of Stack Exchange." After the success of Stack Overflow the creators of the service tried to use the same tools for question and answer sites relating to other topics. Everything from personal fitness to Star Trek the Next Generation. None of these alternative "exchanges" for questions and answers following the model of Stack Overflow have been quite as successful. This is an example of the importance of the dynamic. As it turns out the particular communication dynamic facilitated by the set of functions unique to Stack Overflow is not ideal for question and answer on other topics. By thinking in terms of dynamics we can begin to look at what specific properties of any given function, or layer, lead to a particular result, and we can begin to work toward and understanding of why something like Stack Overflow might not work for personal fitness. It could be a matter of the people who tend to have fitness questions, it could have to do with the nature of the information, that is, programing questions tend to have a very finite and easily demonstrable answer, whereas answers of health and fitness are grey. Perhaps this means that the idea of closing a question once an answer has been reach ends up as a negative function in the discussion of health related topics. If the idea that an answer has been reached and discussion is closed feels counterintuitive then as a dynamic this is not the sort of thing that will drive a user to continue to use the tool.

With this in mind the question then is one of layers, and dynamics. The question is not how do we use the tools of massive collaboration developed and used by open source programmers, but rather how can we look at the functions those tools perform, the layers each represent, and the communication or collaboration dynamics that those layers create. Then we must rebuild and reframe those functions to fit to create and facilitate dynamics of communication, and forms of collaboration that are fruitful in the context of democratic government. In a sense this is no different than the analysis we can see undertaken in the conversations of the Federalist Papers, or the transcript of debate on the floor as the US Constitution was authored. The founding fathers of the United States assessed the functions and dynamics of the monarchy that came before, assessed the dynamics created, and developed new functions to facilitate what they thought to be more ideal dynamics. In doing this they added layers. The election process and the system of representatives is a series of layers all stacked inlace of a monarch. From this point the goal shall be to find even further layers, to continue that march toward decentralization. Where are the layers left to be installed between the desires and needs of the people, and the current endpoint of the system by which those desires become laws? Where might we use the lessons of massive collaboration on software programs to find and add these layers? Where might we create new dynamics of communication that give to the people greater power to impact their democracy?
